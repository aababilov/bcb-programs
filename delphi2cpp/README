Настоящий переводчик принимает на вход файл с синтаксически корректным и семантически произвольным кодом на Pascal (Delphi), не требует НИКАКИХ модулей, указанных в списке uses, и выдает .cpp (либо пару .cpp/.h для unit) файл с эквивалентным кодом на C++. Код выдается с расстановкой отступов, по умолчанию это 2 пробела, их число можно изменить. Возможно указание верхних границ для типов перечисления (нижней границей подразумевается 0) в отдельном файле особого формата (см. ниже). Это полезно для корректного перевода задания границ массива.
Для вывода справки запустите программу с опцией -h.
Разрабатывался в первую очередь для переноса текстов из Delphi в C++Builder. Создан шаблонный класс StaticArray для Pascal-массивов.
Стандартные типы Pascal (Delphi) переводятся на C++ так:
Boolean -> bool
ByteBool -> unsigned char
WordBool -> unsigned short
LongBool -> int
Char -> char
AnsiChar -> char
WideChar -> wchar_t
Integer -> int
Cardinal -> unsigned long
Shortint -> signed char
Smallint -> short
Longint -> long
Int64 -> __int64
Byte -> BYTE
Word -> WORD
Longword -> unsigned long
DWORD -> DWORD
Real -> float
Double -> double
Single -> float
Extended -> long double
WideString -> WideString
AnsiString -> AnsiString
ShortString -> ShortString
//---------------------------------------------------------------------------
Возможные перспективы разработки.
1. Использование полной таблицы символов (в настоящей версии запоминаются только типы перечисления, определенные в данном файле), что может подразумевать необходимость предоставления для полного перевода всех модулей, указанных в списке uses.
2. Поддержка оператора with. Пока при нахождении with выдается предупреждение с указанием параметров оператора. 
3. Поддержка различных областей видимости. Хотелось бы почитать исходные тексты реального компилятора (например, gcc), заодно узнать, как оптимально поддерживать описание типа record. Само по себе это несложно, однако переводчик уже обрабатывает тексты, содержащие синтаксические ошибки - при работе с областями видимости появляются дополнительные проблемы восстановления парсера.
Кроме того, лексический анализатор сразу переводит названия типов Pascal (Delphi) в их эквиваленты
4. Поддержка диапазонов, задаваемых в операторе case (пока выдается предупреждение). Это заставит помнить все константы для расчетов верхней и нижней границ.
5. Понимание задания способа вызова функции при описании типа указателя на функцию. Например, сейчас конструкция
type 
  TFunPtr = function: char;
переведется без проблем, а
type 
  TFunPtr = function: char; stdcall;
вызовет ошибку. Это связано с особенностями грамматики: после считывания точки с запятой неясно, свернить ли "function: char" в определение типа (которое не может оканчиваться на ";") или читать дальше "stdcall" и только сейчас выполнить свертку. Я долго боролся с этой проблемой, но необходимую грамматику выписать не смог, поэтому сейчас указание типа вызова приводит к ошибке.
6. Обработка процедур и функций модуля System, например, Writeln, Readln, Inc, Exclude. Перевод Writeln/Readln/Assign/Reset/Rewrite, с заданием чтения из FILE*(стиль С) или stream (стиль С++).
7. Перевод с учетом директив условной компиляции. Например:
на Pascal (Delphi):
{$IFDEF ABC}
function
{$ELSE}
procedure
{$IFEND}
  AFun(i: integer)
    {$IFDEF ABC}
    : integer
    {$IFEND};
begin
end;
на C++:

#ifdef ABC
int AFun(int i)
#else
void AFun(int i)
#endif
{
}

либо

#ifdef ABC
int 
#else
void 
#endif
AFun(int i)
{
}

Пока директивы условной компиляции просто переписываются в стиле С++, предполагается, что код на Pascal (Delphi) синтаксически корректен без всех директив, т. е. в приведенном выше примере будет выдана ошибка.
Предполагается такой путь: предусмотреть все варианты получаемого текста после препроцессорной обработки, а затем помучиться, как это можно сократить.
8. Поддержка всех опций EXTERNALSUM, NOINCLUDE, HPPEMIT и т. д., а также перевод опций компиляции вроде {$?+/-}, где ? - буква.
//---------------------------------------------------------------------------
Формат файла дополнительных данных
Файл состоит из произвольного числа секций двух видов, идущих в произвольном порядке. Каждая секция начинается с новой строки заголовком: символ [, буква H или T (в любом регистре) и произвольные символы до конца строки. Файл указывается опцией -d.
1. Секция hpp-модулей (буква H). Содержит список модулей (на каждой строке - название), которые будут переведены из списка uses строкой #include <*.hpp>. Все остальные модули добавляются как #include "*.h".
2. Секция типов пречисления (буква T). Содержит пары ИмяТипа <перевод строки> Верхняя граница.
Пример файла:
[hpps]
Windows
Messages
stdCtrls
[types]
TCanvasOrientation
coRightToLeft
[hdfgfghhgkjgj]
SthUnit1
SthUnit2
